------------------------------------------------------------------------
-- Project ???
--
-- Sierpinski space
------------------------------------------------------------------------

module Topology.Core where

open import Agda.Primitive
open import Topology.PowerSet
open import Relation.Binary.PropositionalEquality
open import Data.Product
open import Data.Unit
open import Data.Empty

------------------------------------------------------------------------
-- Topology on a set X
record topology {â„“} (k m : Level) (X : Set â„“) : SetÏ‰â‚ where
    field
        Open : â„™ k X â†’ Set m -- the open subsets of X
        âˆ…-open : Open (empty X)
        full-open : Open (full X)
        âˆ©-open : âˆ€ U V â†’ Open U â†’ Open V â†’ Open (U âˆ© V)
        union-open : âˆ€ {I : Set k} (S : I â†’ â„™ k X) â†’ (âˆ€ i â†’ Open (S i)) â†’ Open (union S)

discrete-topology : {â„“ k : Level} (X : Set â„“) â†’ topology k lzero X
discrete-topology X =
    record
        { Open = Î» _ â†’ âŠ¤
        ; âˆ…-open = tt
        ; full-open = tt
        ; âˆ©-open = Î» _ _ _ _ â†’ tt
        ; union-open = Î» _ _ â†’ tt
        }

indiscrete-topology : {â„“ k : Level} (X : Set â„“) â†’ topology k (â„“ âŠ” k) X
indiscrete-topology X =
    record
        { Open = Î» U â†’ âˆ€ x â†’ U x â†’ âˆ€ y â†’ U y
        ; âˆ…-open = Î» { p () y}
        ; full-open = Î» p x y â†’ ğŸ™-intro
        ; âˆ©-open = Î» U V OpenU OpenV x UVx z â†’ (OpenU x (âˆ©-âŠ†-left U V x UVx) z) ,
                                               (OpenV x (âˆ©-âŠ†-right U V x UVx) z)
        ; union-open =
            Î» { S Si-open x (i , xSi) y â†’ i , Si-open i x xSi y }
        }

-- The topology generated by a family B of subsets closed under binary intersection
base : {â„“ k j : Level} {X : Set â„“} {I : Set k}
    â†’ (B : I â†’ (â„™ j X))
    â†’ ((x : X) â†’ x âˆˆ union B)
    â†’ (âˆ€ {i j x} â†’ x âˆˆ B i â†’ x âˆˆ B j â†’ Î£[ k âˆˆ I ] (x âˆˆ B k) Ã— (B k âŠ† B i âˆ© B j))
    â†’ topology j (â„“ âŠ” k âŠ” j) X
base {â„“ = â„“} {k = k} {j = j} {X = X} {I = I} B Bcovers Bbase =
  record
    { Open = Open'
    ; âˆ…-open = Î» { () }
    ; full-open = Î» {x} _ â†’ (projâ‚ (Bcovers x)) , ((Î» y _ â†’ ğŸ™-intro) , projâ‚‚ (Bcovers x))
    ; âˆ©-open = âˆ©-open'
    ; union-open = {!!}
    }
  where
    Open' : (U : X â†’ Set j) â†’ Set (â„“ âŠ” k âŠ” j)
    Open' = Î» U â†’ âˆ€ {x} â†’ x âˆˆ U â†’ Î£[ i âˆˆ I ] (B i âŠ† U) Ã— x âˆˆ B i

    index-of : {x : X} {U : â„™ j X} â†’ x âˆˆ U â†’ Open' U â†’ I
    index-of xâˆˆU OpenU = projâ‚ (OpenU xâˆˆU)

    âˆ©-open' : (U V : â„™ j X) â†’ Open' U â†’ Open' V â†’ Open' (U âˆ© V)
    âˆ©-open' U V OpenU OpenV xâˆˆUâˆ©V = {!!}

    union-open' : {J : Set j} (S : J â†’ â„™ j X) â†’ ((m : J) â†’ Open' (S m)) â†’ Open' (union S)
    union-open' = {!!}
